(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["npm.ignore-walk"],{

/***/ "../node_modules/ignore-walk/index.js":
/*!********************************************!*\
  !*** ../node_modules/ignore-walk/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nconst fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst path = __webpack_require__(/*! path */ \"../node_modules/path-browserify/index.js\")\nconst EE = __webpack_require__(/*! events */ \"../node_modules/events/events.js\").EventEmitter\nconst Minimatch = __webpack_require__(/*! minimatch */ \"../node_modules/minimatch/minimatch.js\").Minimatch\n\nclass Walker extends EE {\n  constructor (opts) {\n    opts = opts || {}\n    super(opts)\n    this.path = opts.path || process.cwd()\n    this.basename = path.basename(this.path)\n    this.ignoreFiles = opts.ignoreFiles || [ '.ignore' ]\n    this.ignoreRules = {}\n    this.parent = opts.parent || null\n    this.includeEmpty = !!opts.includeEmpty\n    this.root = this.parent ? this.parent.root : this.path\n    this.follow = !!opts.follow\n    this.result = this.parent ? this.parent.result : new Set()\n    this.entries = null\n    this.sawError = false\n  }\n\n  sort (a, b) {\n    return a.localeCompare(b)\n  }\n\n  emit (ev, data) {\n    let ret = false\n    if (!(this.sawError && ev === 'error')) {\n      if (ev === 'error')\n        this.sawError = true\n      else if (ev === 'done' && !this.parent) {\n        data = Array.from(data)\n          .map(e => /^@/.test(e) ? `./${e}` : e).sort(this.sort)\n        this.result = data\n      }\n\n      if (ev === 'error' && this.parent)\n        ret = this.parent.emit('error', data)\n      else\n        ret = super.emit(ev, data)\n    }\n    return ret\n  }\n\n  start () {\n    fs.readdir(this.path, (er, entries) =>\n      er ? this.emit('error', er) : this.onReaddir(entries))\n    return this\n  }\n\n  isIgnoreFile (e) {\n    return e !== \".\" &&\n      e !== \"..\" &&\n      -1 !== this.ignoreFiles.indexOf(e)\n  }\n\n  onReaddir (entries) {\n    this.entries = entries\n    if (entries.length === 0) {\n      if (this.includeEmpty)\n        this.result.add(this.path.substr(this.root.length + 1))\n      this.emit('done', this.result)\n    } else {\n      const hasIg = this.entries.some(e =>\n        this.isIgnoreFile(e))\n\n      if (hasIg)\n        this.addIgnoreFiles()\n      else\n        this.filterEntries()\n    }\n  }\n\n  addIgnoreFiles () {\n    const newIg = this.entries\n      .filter(e => this.isIgnoreFile(e))\n\n    let igCount = newIg.length\n    const then = _ => {\n      if (--igCount === 0)\n        this.filterEntries()\n    }\n\n    newIg.forEach(e => this.addIgnoreFile(e, then))\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    fs.readFile(ig, 'utf8', (er, data) =>\n      er ? this.emit('error', er) : this.onReadIgnoreFile(file, data, then))\n  }\n\n  onReadIgnoreFile (file, data, then) {\n    const mmopt = {\n      matchBase: true,\n      dot: true,\n      flipNegate: true,\n      nocase: true\n    }\n    const rules = data.split(/\\r?\\n/)\n      .filter(line => !/^#|^$/.test(line.trim()))\n      .map(r => new Minimatch(r, mmopt))\n\n    this.ignoreRules[file] = rules\n\n    then()\n  }\n\n  filterEntries () {\n    // at this point we either have ignore rules, or just inheriting\n    // this exclusion is at the point where we know the list of\n    // entries in the dir, but don't know what they are.  since\n    // some of them *might* be directories, we have to run the\n    // match in dir-mode as well, so that we'll pick up partials\n    // of files that will be included later.  Anything included\n    // at this point will be checked again later once we know\n    // what it is.\n    const filtered = this.entries.map(entry => {\n      // at this point, we don't know if it's a dir or not.\n      const passFile = this.filterEntry(entry)\n      const passDir = this.filterEntry(entry, true)\n      return (passFile || passDir) ? [entry, passFile, passDir] : false\n    }).filter(e => e)\n\n    // now we stat them all\n    // if it's a dir, and passes as a dir, then recurse\n    // if it's not a dir, but passes as a file, add to set\n    let entryCount = filtered.length\n    if (entryCount === 0) {\n      this.emit('done', this.result)\n    } else {\n      const then = _ => {\n        if (-- entryCount === 0)\n          this.emit('done', this.result)\n      }\n      filtered.forEach(filt => {\n        const entry = filt[0]\n        const file = filt[1]\n        const dir = filt[2]\n        this.stat(entry, file, dir, then)\n      })\n    }\n  }\n\n  onstat (st, entry, file, dir, then) {\n    const abs = this.path + '/' + entry\n    if (!st.isDirectory()) {\n      if (file)\n        this.result.add(abs.substr(this.root.length + 1))\n      then()\n    } else {\n      // is a directory\n      if (dir)\n        this.walker(entry, then)\n      else\n        then()\n    }\n  }\n\n  stat (entry, file, dir, then) {\n    const abs = this.path + '/' + entry\n    fs[this.follow ? 'stat' : 'lstat'](abs, (er, st) => {\n      if (er)\n        this.emit('error', er)\n      else\n        this.onstat(st, entry, file, dir, then)\n    })\n  }\n\n  walkerOpt (entry) {\n    return {\n      path: this.path + '/' + entry,\n      parent: this,\n      ignoreFiles: this.ignoreFiles,\n      follow: this.follow,\n      includeEmpty: this.includeEmpty\n    }\n  }\n\n  walker (entry, then) {\n    new Walker(this.walkerOpt(entry)).on('done', then).start()\n  }\n\n  filterEntry (entry, partial) {\n    let included = true\n\n    // this = /a/b/c\n    // entry = d\n    // parent /a/b sees c/d\n    if (this.parent && this.parent.filterEntry) {\n      var pt = this.basename + \"/\" + entry\n      included = this.parent.filterEntry(pt, partial)\n    }\n\n    this.ignoreFiles.forEach(f => {\n      if (this.ignoreRules[f]) {\n        this.ignoreRules[f].forEach(rule => {\n          // negation means inclusion\n          // so if it's negated, and already included, no need to check\n          // likewise if it's neither negated nor included\n          if (rule.negate !== included) {\n            // first, match against /foo/bar\n            // then, against foo/bar\n            // then, in the case of partials, match with a /\n            const match = rule.match('/' + entry) ||\n              rule.match(entry) ||\n              (!!partial && (\n                rule.match('/' + entry + '/') ||\n                rule.match(entry + '/'))) ||\n              (!!partial && rule.negate && (\n                rule.match('/' + entry, true) ||\n                rule.match(entry, true)))\n\n            if (match)\n              included = rule.negate\n          }\n        })\n      }\n    })\n\n    return included\n  }\n}\n\nclass WalkerSync extends Walker {\n  constructor (opt) {\n    super(opt)\n  }\n\n  start () {\n    this.onReaddir(fs.readdirSync(this.path))\n    return this\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    this.onReadIgnoreFile(file, fs.readFileSync(ig, 'utf8'), then)\n  }\n\n  stat (entry, file, dir, then) {\n    const abs = this.path + '/' + entry\n    const st = fs[this.follow ? 'statSync' : 'lstatSync'](abs)\n    this.onstat(st, entry, file, dir, then)\n  }\n\n  walker (entry, then) {\n    new WalkerSync(this.walkerOpt(entry)).start()\n    then()\n  }\n}\n\nconst walk = (options, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new Walker(options).on('done', resolve).on('error', reject).start()\n  })\n  return callback ? p.then(res => callback(null, res), callback) : p\n}\n\nconst walkSync = options => {\n  return new WalkerSync(options).start().result\n}\n\nmodule.exports = walk\nwalk.sync = walkSync\nwalk.Walker = Walker\nwalk.WalkerSync = WalkerSync\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///../node_modules/ignore-walk/index.js?");

/***/ })

}]);