(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["npm.npm-packlist"],{

/***/ "../node_modules/npm-packlist/index.js":
/*!*********************************************!*\
  !*** ../node_modules/npm-packlist/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\n// Do a two-pass walk, first to get the list of packages that need to be\n// bundled, then again to get the actual files and folders.\n// Keep a cache of node_modules content and package.json data, so that the\n// second walk doesn't have to re-do all the same work.\n\nconst bundleWalk = __webpack_require__(/*! npm-bundled */ \"../node_modules/npm-bundled/index.js\")\nconst BundleWalker = bundleWalk.BundleWalker\nconst BundleWalkerSync = bundleWalk.BundleWalkerSync\n\nconst ignoreWalk = __webpack_require__(/*! ignore-walk */ \"../node_modules/ignore-walk/index.js\")\nconst IgnoreWalker = ignoreWalk.Walker\nconst IgnoreWalkerSync = ignoreWalk.WalkerSync\n\nconst rootBuiltinRules = Symbol('root-builtin-rules')\nconst packageNecessaryRules = Symbol('package-necessary-rules')\nconst path = __webpack_require__(/*! path */ \"../node_modules/path-browserify/index.js\")\n\nconst normalizePackageBin = __webpack_require__(/*! npm-normalize-package-bin */ \"../node_modules/npm-normalize-package-bin/index.js\")\n\nconst defaultRules = [\n  '.npmignore',\n  '.gitignore',\n  '**/.git',\n  '**/.svn',\n  '**/.hg',\n  '**/CVS',\n  '**/.git/**',\n  '**/.svn/**',\n  '**/.hg/**',\n  '**/CVS/**',\n  '/.lock-wscript',\n  '/.wafpickle-*',\n  '/build/config.gypi',\n  'npm-debug.log',\n  '**/.npmrc',\n  '.*.swp',\n  '.DS_Store',\n  '**/.DS_Store/**',\n  '._*',\n  '**/._*/**',\n  '*.orig',\n  '/package-lock.json',\n  '/yarn.lock',\n  'archived-packages/**',\n  'core',\n  '!core/',\n  '!**/core/',\n  '*.core',\n  '*.vgcore',\n  'vgcore.*',\n  'core.+([0-9])',\n]\n\n// There may be others, but :?|<> are handled by node-tar\nconst nameIsBadForWindows = file => /\\*/.test(file)\n\n// a decorator that applies our custom rules to an ignore walker\nconst npmWalker = Class => class Walker extends Class {\n  constructor (opt) {\n    opt = opt || {}\n\n    // the order in which rules are applied.\n    opt.ignoreFiles = [\n      rootBuiltinRules,\n      'package.json',\n      '.npmignore',\n      '.gitignore',\n      packageNecessaryRules\n    ]\n\n    opt.includeEmpty = false\n    opt.path = opt.path || process.cwd()\n    const dirName = path.basename(opt.path)\n    const parentName = path.basename(path.dirname(opt.path))\n    opt.follow =\n      dirName === 'node_modules' ||\n      (parentName === 'node_modules' && /^@/.test(dirName))\n    super(opt)\n\n    // ignore a bunch of things by default at the root level.\n    // also ignore anything in node_modules, except bundled dependencies\n    if (!this.parent) {\n      this.bundled = opt.bundled || []\n      this.bundledScopes = Array.from(new Set(\n        this.bundled.filter(f => /^@/.test(f))\n        .map(f => f.split('/')[0])))\n      const rules = defaultRules.join('\\n') + '\\n'\n      this.packageJsonCache = opt.packageJsonCache || new Map()\n      super.onReadIgnoreFile(rootBuiltinRules, rules, _=>_)\n    } else {\n      this.bundled = []\n      this.bundledScopes = []\n      this.packageJsonCache = this.parent.packageJsonCache\n    }\n  }\n\n  onReaddir (entries) {\n    if (!this.parent) {\n      entries = entries.filter(e =>\n        e !== '.git' &&\n        !(e === 'node_modules' && this.bundled.length === 0)\n      )\n    }\n    return super.onReaddir(entries)\n  }\n\n  filterEntry (entry, partial) {\n    // get the partial path from the root of the walk\n    const p = this.path.substr(this.root.length + 1)\n    const pkgre = /^node_modules\\/(@[^\\/]+\\/?[^\\/]+|[^\\/]+)(\\/.*)?$/\n    const isRoot = !this.parent\n    const pkg = isRoot && pkgre.test(entry) ?\n      entry.replace(pkgre, '$1') : null\n    const rootNM = isRoot && entry === 'node_modules'\n    const rootPJ = isRoot && entry === 'package.json'\n\n    return (\n      // if we're in a bundled package, check with the parent.\n      /^node_modules($|\\/)/i.test(p) ? this.parent.filterEntry(\n          this.basename + '/' + entry, partial)\n\n      // if package is bundled, all files included\n      // also include @scope dirs for bundled scoped deps\n      // they'll be ignored if no files end up in them.\n      // However, this only matters if we're in the root.\n      // node_modules folders elsewhere, like lib/node_modules,\n      // should be included normally unless ignored.\n      : pkg ? -1 !== this.bundled.indexOf(pkg) ||\n        -1 !== this.bundledScopes.indexOf(pkg)\n\n      // only walk top node_modules if we want to bundle something\n      : rootNM ? !!this.bundled.length\n\n      // always include package.json at the root.\n      : rootPJ ? true\n\n      // otherwise, follow ignore-walk's logic\n      : super.filterEntry(entry, partial)\n    )\n  }\n\n  filterEntries () {\n    if (this.ignoreRules['package.json'])\n      this.ignoreRules['.gitignore'] = this.ignoreRules['.npmignore'] = null\n    else if (this.ignoreRules['.npmignore'])\n      this.ignoreRules['.gitignore'] = null\n    this.filterEntries = super.filterEntries\n    super.filterEntries()\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    if (this.packageJsonCache.has(ig))\n      this.onPackageJson(ig, this.packageJsonCache.get(ig), then)\n    else\n      super.addIgnoreFile(file, then)\n  }\n\n  onPackageJson (ig, pkg, then) {\n    this.packageJsonCache.set(ig, pkg)\n\n    // if there's a bin, browser or main, make sure we don't ignore it\n    // also, don't ignore the package.json itself!\n    //\n    // Weird side-effect of this: a readme (etc) file will be included\n    // if it exists anywhere within a folder with a package.json file.\n    // The original intent was only to include these files in the root,\n    // but now users in the wild are dependent on that behavior for\n    // localized documentation and other use cases.  Adding a `/` to\n    // these rules, while tempting and arguably more \"correct\", is a\n    // breaking change.\n    const rules = [\n      pkg.browser ? '!' + pkg.browser : '',\n      pkg.main ? '!' + pkg.main : '',\n      '!package.json',\n      '!npm-shrinkwrap.json',\n      '!@(readme|copying|license|licence|notice|changes|changelog|history){,.*[^~$]}'\n    ]\n    if (pkg.bin) {\n      // always an object, because normalized already\n      for (const key in pkg.bin)\n        rules.push('!' + pkg.bin[key])\n    }\n\n    const data = rules.filter(f => f).join('\\n') + '\\n'\n    super.onReadIgnoreFile(packageNecessaryRules, data, _=>_)\n\n    if (Array.isArray(pkg.files))\n      super.onReadIgnoreFile('package.json', '*\\n' + pkg.files.map(\n        f => '!' + f + '\\n!' + f.replace(/\\/+$/, '') + '/**'\n      ).join('\\n') + '\\n', then)\n    else\n      then()\n  }\n\n  // override parent stat function to completely skip any filenames\n  // that will break windows entirely.\n  // XXX(isaacs) Next major version should make this an error instead.\n  stat (entry, file, dir, then) {\n    if (nameIsBadForWindows(entry))\n      then()\n    else\n      super.stat(entry, file, dir, then)\n  }\n\n  // override parent onstat function to nix all symlinks\n  onstat (st, entry, file, dir, then) {\n    if (st.isSymbolicLink())\n      then()\n    else\n      super.onstat(st, entry, file, dir, then)\n  }\n\n  onReadIgnoreFile (file, data, then) {\n    if (file === 'package.json')\n      try {\n        const ig = path.resolve(this.path, file)\n        this.onPackageJson(ig, normalizePackageBin(JSON.parse(data)), then)\n      } catch (er) {\n        // ignore package.json files that are not json\n        then()\n      }\n    else\n      super.onReadIgnoreFile(file, data, then)\n  }\n\n  sort (a, b) {\n    return sort(a, b)\n  }\n}\n\nclass Walker extends npmWalker(IgnoreWalker) {\n  walker (entry, then) {\n    new Walker(this.walkerOpt(entry)).on('done', then).start()\n  }\n}\n\nclass WalkerSync extends npmWalker(IgnoreWalkerSync) {\n  walker (entry, then) {\n    new WalkerSync(this.walkerOpt(entry)).start()\n    then()\n  }\n}\n\nconst walk = (options, callback) => {\n  options = options || {}\n  const p = new Promise((resolve, reject) => {\n    const bw = new BundleWalker(options)\n    bw.on('done', bundled => {\n      options.bundled = bundled\n      options.packageJsonCache = bw.packageJsonCache\n      new Walker(options).on('done', resolve).on('error', reject).start()\n    })\n    bw.start()\n  })\n  return callback ? p.then(res => callback(null, res), callback) : p\n}\n\nconst walkSync = options => {\n  options = options || {}\n  const bw = new BundleWalkerSync(options).start()\n  options.bundled = bw.result\n  options.packageJsonCache = bw.packageJsonCache\n  const walker = new WalkerSync(options)\n  walker.start()\n  return walker.result\n}\n\n// optimize for compressibility\n// extname, then basename, then locale alphabetically\n// https://twitter.com/isntitvacant/status/1131094910923231232\nconst sort = (a, b) => {\n  const exta = path.extname(a).toLowerCase()\n  const extb = path.extname(b).toLowerCase()\n  const basea = path.basename(a).toLowerCase()\n  const baseb = path.basename(b).toLowerCase()\n\n  return exta.localeCompare(extb) ||\n    basea.localeCompare(baseb) ||\n    a.localeCompare(b)\n}\n\n\nmodule.exports = walk\nwalk.sync = walkSync\nwalk.Walker = Walker\nwalk.WalkerSync = WalkerSync\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///../node_modules/npm-packlist/index.js?");

/***/ })

}]);